import { test, expect } from 'vitest'
import { parse, htmlify } from './atomic'

const page = {
  "code": "684b48b7-6f5e-4c76-a016-fa68559822a5",
  "type": "page",
  "creator": "vh-NTHVvlKZqRxc8LyyTNok65yQ55a_PJ1zWLb9G2JI",
  "contentType": "text/html",
  "title": "syncState",
  "description": "Warp SDK provides a way to import the state of a large or busy contract using the `syncState` function.",
  "topics": [
    "warp",
    "smartweave"
  ],
  "protocol": "PermaPages-v0.4",
  "content": "# Warp's syncState feature\n\nUnderstanding the syncState feature of the Warp SDK\n\nAs you know, SmartWeave contracts evaluate lazily; the system works like the event sourcing pattern, where transactions are published to a data source and materialized views compute to convert raw data into the information or state. This pattern works great for immutable data sources, which Arweave is a large immutable data lake. SmartWeave contracts take advantage of this pattern by writing transactions with specific tags to interact with a SmartWeaveContract. The Interaction evaluates the state upon reading via deterministic ordering with the Warp Sequencer.\n\nAs contracts build up a large volume of transactions, the evaluation process can get slow and un performant if you start at zero every time you calculate the state. Warp SDK uses indexDB to cache the most recent evaluated state so that your application does not have to start from zero for a previously visited user. But what if a user visits for the first time, and the app has to evaluate the state from zero? \n\nThat was the case until the Warp Team released a new feature. The feature is called syncState. This feature allows you to sync the state of the contract with a remote server called a D.R.E (Delegated Resolution Environment). These servers can monitor and keep a recent state cache for many SmartWeaveContracts. The result is that a new user does not have to wait for the entire state to evaluate. \n\nCurrently, D.R.E.s only support contracts that do not have unsafeClient in them. Still, the reality SmartWeaveContracts compose with other SmartWeaveContracts, so preventing Interactions in the wild will be hard. The Warp Team has documented on their roadmap to include support for `unsafeClient` in their network of D.R.E. servers, also developers can run their own D.R.E Servers. You can read more about D.R.E. here - https://academy.warp.cc/docs/dre/overview\n\n## SyncState\n\nThe syncState feature allows your warpSDK client to retrieve state from a remote server at a specific sort key; then the browser can evaluate from that checkpoint forward, which then becomes stored in the IndexDB cache, so the browser can evaluate all interactions locally as writeInteractions occur. This workflow dramatically increases the performance and reliability of permaweb apps as the app needs to scale. It naturally creates a backstop for the D.R.E. if they are no longer operational, the application will still work, even if it is very slow. As the technology matures, I see this feature becoming an option to select in an Arweave Wallet.\n\n\n### Example\n\n```js\nimport { WarpFactory } from 'warp-contracts/mjs'\n\nconst warp = WarpFactory.forMainnet()\nconst CACHE = 'https://cache.permapages.app/contract' \nconst options = { allowBigInt: true, internalWrites: true, unsafeClient: 'allow' }\n\nasync function initializeContracts() {\n  // syncState with BAR\n  await warp\n    .contract(\"VFr3Bk-uM-motpNNkkFg4lNW1BMmSfzqsVO551Ho4hA\")\n    .syncState(\"https://cache.permapages.app/contract\", { validity: true })\n\t\t.then(c => c.setEvaluationOptions(options).readState();\n  // syncState with STAMPS\n  await warp\n    .contract(\"61vg8n54MGSC9ZHfSVAtQp4WjNb20TaThu6bkQ86pPI\")\n    .syncState(\"https://cache.permapages.app/contract\", { validity: true }}\n\t\t.then(c => c.setEvaluationOptions(options).readState();\n}\n```\n\nThe nice thing about this feature is that you should only have to do it once per user session, and it only takes a few seconds to sync. The result is a fast write interactions and state reads. \n\nSince I work with BAR and STAMPs, I sync those upon initialization to warm up any other interactions for the application.\n\nI am also using https://cache.permapages.app/contract as the sync service because it supports 'unsafeClient', which is required to get the correct balances for the BAR contract.\n\n## Summary\n\n`syncState` is a new feature of the Warp SDK and can significantly improve the performance of SmartContracts without having to resort to snowflake solutions, as the D.R.E. systems will evolve into full decentralized server nodes.\n\nIn the future, or if you have zero dependencies on unsafeClient, you can try the new `remoteStateSync` flag in the evaluation options:\n\nhttps://academy.warp.cc/docs/sdk/advanced/evaluation-options#state-auto-sync\n\n",
  "html": "<div class=\"flex flex-col md:flex-row space-x-4\">  \n        <div class=\"flex-1 md:min-h-screen\">\n          <div class=\"prose md:prose-lg lg:prose-xl m-8 md:mx-24 dark:text-[#D3D7E0] dark:prose-headings:text-[#D3D7E0] dark:prose-headings:text-[#D3D7E0]\">\n          <h1>Warp's syncState feature</h1>\n<p>Understanding the syncState feature of the Warp SDK</p>\n<p>As you know, SmartWeave contracts evaluate lazily; the system works like the event sourcing pattern, where transactions are published to a data source and materialized views compute to convert raw data into the information or state. This pattern works great for immutable data sources, which Arweave is a large immutable data lake. SmartWeave contracts take advantage of this pattern by writing transactions with specific tags to interact with a SmartWeaveContract. The Interaction evaluates the state upon reading via deterministic ordering with the Warp Sequencer.</p>\n<p>As contracts build up a large volume of transactions, the evaluation process can get slow and un performant if you start at zero every time you calculate the state. Warp SDK uses indexDB to cache the most recent evaluated state so that your application does not have to start from zero for a previously visited user. But what if a user visits for the first time, and the app has to evaluate the state from zero?</p>\n<p>That was the case until the Warp Team released a new feature. The feature is called syncState. This feature allows you to sync the state of the contract with a remote server called a D.R.E (Delegated Resolution Environment). These servers can monitor and keep a recent state cache for many SmartWeaveContracts. The result is that a new user does not have to wait for the entire state to evaluate.</p>\n<p>Currently, D.R.E.s only support contracts that do not have unsafeClient in them. Still, the reality SmartWeaveContracts compose with other SmartWeaveContracts, so preventing Interactions in the wild will be hard. The Warp Team has documented on their roadmap to include support for <code>unsafeClient</code> in their network of D.R.E. servers, also developers can run their own D.R.E Servers. You can read more about D.R.E. here - <a href=\"https://academy.warp.cc/docs/dre/overview\">https://academy.warp.cc/docs/dre/overview</a></p>\n<h2>SyncState</h2>\n<p>The syncState feature allows your warpSDK client to retrieve state from a remote server at a specific sort key; then the browser can evaluate from that checkpoint forward, which then becomes stored in the IndexDB cache, so the browser can evaluate all interactions locally as writeInteractions occur. This workflow dramatically increases the performance and reliability of permaweb apps as the app needs to scale. It naturally creates a backstop for the D.R.E. if they are no longer operational, the application will still work, even if it is very slow. As the technology matures, I see this feature becoming an option to select in an Arweave Wallet.</p>\n<h3>Example</h3>\n<pre><code class=\"language-js\">import { WarpFactory } from 'warp-contracts/mjs'\n\nconst warp = WarpFactory.forMainnet()\nconst CACHE = 'https://cache.permapages.app/contract' \nconst options = { allowBigInt: true, internalWrites: true, unsafeClient: 'allow' }\n\nasync function initializeContracts() {\n  // syncState with BAR\n  await warp\n    .contract(&quot;VFr3Bk-uM-motpNNkkFg4lNW1BMmSfzqsVO551Ho4hA&quot;)\n    .syncState(&quot;https://cache.permapages.app/contract&quot;, { validity: true })\n\t\t.then(c =&gt; c.setEvaluationOptions(options).readState();\n  // syncState with STAMPS\n  await warp\n    .contract(&quot;61vg8n54MGSC9ZHfSVAtQp4WjNb20TaThu6bkQ86pPI&quot;)\n    .syncState(&quot;https://cache.permapages.app/contract&quot;, { validity: true }}\n\t\t.then(c =&gt; c.setEvaluationOptions(options).readState();\n}\n</code></pre>\n<p>The nice thing about this feature is that you should only have to do it once per user session, and it only takes a few seconds to sync. The result is a fast write interactions and state reads.</p>\n<p>Since I work with BAR and STAMPs, I sync those upon initialization to warm up any other interactions for the application.</p>\n<p>I am also using <a href=\"https://cache.permapages.app/contract\">https://cache.permapages.app/contract</a> as the sync service because it supports 'unsafeClient', which is required to get the correct balances for the BAR contract.</p>\n<h2>Summary</h2>\n<p><code>syncState</code> is a new feature of the Warp SDK and can significantly improve the performance of SmartContracts without having to resort to snowflake solutions, as the D.R.E. systems will evolve into full decentralized server nodes.</p>\n<p>In the future, or if you have zero dependencies on unsafeClient, you can try the new <code>remoteStateSync</code> flag in the evaluation options:</p>\n<p><a href=\"https://academy.warp.cc/docs/sdk/advanced/evaluation-options#state-auto-sync\">https://academy.warp.cc/docs/sdk/advanced/evaluation-options#state-auto-sync</a></p>\n</div></div>\n        <div class=\"flex-none\">\n          <div class=\"flex flex-col max-w-[300px] justify-end space-y-8\">\n            <div id=\"passport\" class=\"w-full grid items-center mt-16 mr-16\"></div>\n          </div>\n        </div\n      </div>\n      ",
  "profile": false,
  "weavemail": false,
  "ethwallet": "",
  "webpage": "OWy3gKruIU5mPJY_aKqwXzOmA459A6p5GvADUZw_9xQ",
  "timestamp": "2023-03-16T11:46:22.299Z",
  "theme": "default",
  "includeFooter": true,
  "allowStamps": true,
  "noContract": false,
  "noBundlr": false,
  "widgets": [
    {
      "source": "https://stamp-widget.arweave.dev",
      "elementId": "passport",
      "name": "passport",
      "description": "Permapage Passport Widget",
      "version": "latest"
    }
  ]
}

test('ok', () => {
  const result = htmlify(page)
  const result2 = parse(result)
  expect(result2.title).toEqual(page.title)
  expect(result2.description).toEqual(page.description)
  expect(result2.content).toEqual(page.content)
  expect(result2.allowStamps).toEqual(page.allowStamps)
})